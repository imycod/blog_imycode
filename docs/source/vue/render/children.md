# 归一化处理

**它的目的是保证 render 函数返回的 children 参数是一个一维数组，而不是一个多维数组**

## simpleNormalizeChildren

```js
export function simpleNormalizeChildren(children: any) {
    for (let i = 0; i < children.length; i++) {
        if (Array.isArray(children[i])) {
            return Array.prototype.concat.apply([], children)
        }
    }
    return children
}
```

它处理 render 函数返回的 children 参数。
一般来说，render 函数返回的 children 都是 vnode 类型，但是有一个特殊情况，就是函数式组件（functional
component）会返回一个数组而不是一个根节点。
这时候，simpleNormalizeChildren 函数就会把这个数组展平，保证它只有一层深度。

```js
let children = [1, 2, [3, 4], 5]; // => [1, 2, 3, 4, 5];
children = [1, 2, [3, [4]], 5]; // => [1, 2, 3, [4], 5];
```

## 更多例子

```js
const FunctionalComponent = {
    functional: true,
    render(h) {
        return [
            h("h1", "This is a functional component"),
            h("p", "It returns an array of vnodes")
        ];
    }
};
```

假如渲染函数返回的不是一维数组,而是这样的

```js
[
    h("h1", "This is the parent component"),
    [
        h("h2", "This is the first functional component"),
        h("p", "It returns an array of vnodes")
    ],
    [
        h("h2", "This is the second functional component"),
        h("p", "It also returns an array of vnodes")
    ]
];
```

这样的数组很难处理，所以 Vue 会调用 simpleNormalizeChildren 函数，把它展平成一维数组，比如这样：

```js
[
    h("h1", "This is the parent component"),
    h("h2", "This is the first functional component"),
    h("p", "It returns an array of vnodes"),
    h("h2", "This is the second functional component"),
    h("p", "It also returns an array of vnodes")
];
```

## normalizeArrayChildren

```ts
function normalizeArrayChildren(children: any, nestedIndex?: string): Array<VNode> {
    const res = []
    let i, c, last
    for (i = 0; i < children.length; i++) {
        c = children[i]
        if (c == null || typeof c === 'boolean') continue
        last = res[res.length - 1]
//  nested
        if (Array.isArray(c)) {
            res.push.apply(res, normalizeArrayChildren(c, `${nestedIndex || ''}_${i}`))
        } else if (isPrimitive(c)) {
            if (last && last.text) {
                last.text += String(c)
            } else if (c !== '') {
// convert primitive to vnode
                res.push(createTextVNode(c))
            }
        } else {
            if (c.text && last && last.text) {
                res[res.length - 1] = createTextVNode(last.text + c.text)
            } else {
// default key for nested array children (likely generated by v-for)
                if (c.tag && c.key == null && nestedIndex != null) {
                    c.key = `__vlist${nestedIndex}_${i}__`
                }
                res.push(c)
            }
        }
    }
    return res
}
```
这是整个函数的主要代码。它使用一个 for 循环遍历 children 数组中的每个元素 c。首先判断 c 是否为 null 或者布尔类型，如果是，就直接跳过当前循环。然后声明并赋值 last 变量为结果数组 res 中的最后一个元素。

如果 c 是一个数组，就递归调用 normalizeArrayChildren 函数并将其结果追加到 res 中。如果 c 是一个基本类型，就将其转换成一个 VNode 对象并追加到 res 中。如果 c 是一个对象，就直接追加到 res 中。

在处理 c 时，还会判断是否存在 text 属性。如果 c 是一个包含文本内容的节点，并且 last 也是一个包含文本内容的节点，就将这两个节点合并成一个节点。

如果 c 是一个包含子节点的节点，这里默认会为它生成一个默认的 key 属性，以便后续的虚拟 DOM 渲染优化。

最后，将处理后的结果数组 res 返回。
## 更多例子

```js
const children = [
    null,
    "Hello",
    h("span", "World"),
    [h("div", "This is a nested array"), h("p", "It contains two vnodes")],
    false,
    h("h1", "This is the last vnode")
];
```
这个数组包含了各种类型的值，如果你把它传递给 normalizeArrayChildren 函数，它会返回一个只包含 vnode 的一维数组，它是这样的：
```ts
const res = [
  createTextVNode("Hello"),
  h("span", "World"),
  h("div", "This is a nested array", { key: "__vlist_3_0__" }),
  h("p", "It contains two vnodes", { key: "__vlist_3_1__" }),
  h("h1", "This is the last vnode")
];
```
你可以看到，normalizeArrayChildren 函数做了以下几件事：

它忽略了 null 和 false 值。
它把字符串 “Hello” 转化为文本 vnode。
它把嵌套的数组展平，并给每个 vnode 添加了一个 key。
它保留了其他的 vnode。
